---
title: "Практическая работа 005"
author: "dolgov18012005@yandex.ru"
format: 
  md:
    output-file: README.md
---

## Цель работы

1. Зекрепить практические навыки использования языка программирования R для обработки данных
2. Закрепить знания основных функций обработки данных экосистемы tidyverse языка R
3. Закрепить навыки исследования метаданных DNS трафика

## Исходные данные

1. Программное обеспечение Manjaro
2. Rstudio Desktop
3. Интерпретатор языка R 4.5.1

## Задание

Используя программный пакет dplyr языка программирования R провести анализ журналов и ответить на вопросы.

## Ход работы

1. Подготовка данных \
    1.1. Импортируйте данные. \
    1.2. Привести датасеты в вид “аккуратных данных”, преобразовать типы столбцов в соответствии с типом данных \
    1.3. Просмотрите общую структуру данных с помощью функции glimpse() \

2. Анализ \
    2.1. Определить небезопасные точки доступа (без шифрования – OPN) \
    2.2. Определить производителя для каждого обнаруженного устройства \
    2.3. Выявить устройства, использующие последнюю версию протокола шифрования WPA3, и названия точек доступа, реализованных на этих устройствах \
    2.4. Отсортировать точки доступа по интервалу времени, в течение которого они находились на связи, по убыванию. \
    2.5. Обнаружить топ-10 самых быстрых точек доступа. \
    2.6. Отсортировать точки доступа по частоте отправки запросов (beacons) в единиц времени по их убыванию. \
3. Данные клиентов \
    3.1. Определить производителя для каждого обнаруженного устройства
    3.2. Обнаружить устройства, которые НЕ рандомизируют свой MAC адрес
    3.3. Кластеризовать запросы от устройств к точкам доступа по их именам. Определить время появления устройства в зоне радиовидимости и время выхода его из нее.
    3.4. Оценить стабильность уровня сигнала внури кластера во времени. Выявить наиболее стабильный кластер.


### Шаг 1

#### Импорт данных

```{r}
library(readr)
library(dplyr)
library(lubridate)
library(tidyverse)

lines = readLines("P2_wifi_data.csv")

split_str <- which(lines=="")[1]
wifi_data1 = read_csv("P2_wifi_data.csv", skip=0, n_max = split_str-2)
wifi_data2 =  read_csv("P2_wifi_data.csv", skip=split_str)
```

#### Приведем к аккуартному виду таблицу с анонсами беспроводных точек доступа

```{r}
wifi_clean <- wifi_data1 %>%
  rename(.,
        First_time_seen=2,
        Last_time_seen=3,
        Beacons=10,
        IV=11,
        Lan_IP=12,
        ID_length=13
    
  ) %>%
  mutate(
    channel = as.integer(channel),
    Speed = as.integer(Speed),
    First_time_seen = ymd_hms(First_time_seen, tz = "UTC"),
    Last_time_seen = ymd_hms(Last_time_seen, tz = "UTC")
  )

glimpse(wifi_clean)
```

#### Приведем к аккуартному виду таблицу с анонсами беспроводных точек доступа

```{r}
user_clean <- wifi_data2 %>%
  mutate(
    Power = as.integer(Power),
  ) %>%
  rename(
    Station_MAC=1,
    First_time_seen=2,
    Last_time_seen=3,
    Packets=5,
    Probed_ESSIDs=7
    
  )

glimpse(user_clean)
```

### Шаг 2

#### Определим небезопасные точки доступа

```{r}
wifi_clean %>% filter(., Privacy=="OPN")
```

#### Определим производителя для обнаруженных устройств

```{r}
oui = read_delim("manuf.txt", col_names = c("OUI", "Short_name", "Full_name"), delim = "\t", quote = '"') %>% 
  mutate(
    OUI = substr(OUI, 1, 8)
  )

wifi_clean_vendor <- wifi_clean %>%
  mutate(
    OUI = substr(BSSID, 1, 8)
  )

wifi_clean_vendor <- wifi_clean_vendor %>%
  left_join(oui, by = "OUI")
wifi_clean_vendor

```

#### Устройства, использующие WPA3

```{r}
wifi_clean %>%
  filter(str_detect(Privacy, regex("WPA3", ignore_case = TRUE))) %>%
  select(BSSID, ESSID, Privacy)

```

#### Отсортируем точки доступа по интервалу времени, в течение которого они находились на связи, по убыванию.

```{r}
GAP_LIMIT_SEC <- 45 * 60
ap_duration <- wifi_clean %>%
  arrange(BSSID, First_time_seen) %>%
  group_by(BSSID, ESSID) %>%
  filter(!is.na(First_time_seen), !is.na(Last_time_seen)) %>%
  mutate(
    start = First_time_seen,
    prev_end = lag(Last_time_seen),
    gap = as.numeric(difftime(start, prev_end, units = "secs")),
    is_new_session = is.na(gap) | (gap > GAP_LIMIT_SEC),
    session_group = cumsum(is_new_session)
  ) %>%
  group_by(BSSID, ESSID, session_group) %>%
  summarise(
    session_start = min(First_time_seen, na.rm = TRUE),
    session_end   = max(Last_time_seen,  na.rm = TRUE),
    .groups = "drop"
  ) %>%
  group_by(BSSID, ESSID) %>%
  summarise(
    total_time_on_air_sec = sum(as.numeric(difftime(session_end, session_start, units = "secs"))),
    .groups = "drop"
  ) %>%
  arrange(desc(total_time_on_air_sec)) %>%
  select(BSSID, ESSID, total_time_on_air_sec)

ap_duration
```

#### Топ-10 самых быстрых точек доступа

```{r}
wifi_clean %>%
  mutate(Speed = as.numeric(Speed)) %>%
  filter(!is.na(Speed)) %>%
  select(BSSID, ESSID, Speed) %>%
  arrange(desc(Speed)) %>%
  head(10)
```

#### Отсортируем точки доступа по частоте отправки запросов (beacons) в единицу времени по их убыванию.

```{r}
wifi_beacon <- wifi_clean %>%
  group_by(BSSID, ESSID) %>%
  summarise(
    total_beacons = sum(Beacons, na.rm = TRUE),
    first_seen    = min(First_time_seen, na.rm = TRUE),
    last_seen     = max(Last_time_seen,  na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    duration_sec = as.numeric(difftime(last_seen, first_seen, units = "secs")),
    beacon_rate  = ifelse(duration_sec > 0, total_beacons / duration_sec, NA)
  ) %>%
  filter(!is.na(beacon_rate)) %>%
  arrange(desc(beacon_rate)) %>%
  select(BSSID, ESSID, total_beacons, duration_sec, beacon_rate)

wifi_beacon
```

### Шаг 3

#### Определить производителя для каждого обнаруженного устройства

```{r}
user_oui <- user_clean %>%  mutate(
    OUI = substr(Station_MAC, 1, 8)
  )

user_with_vendor <- user_oui %>%
  left_join(oui, by = "OUI")

user_with_vendor
```

#### Обнаружить устройства, которые НЕ рандомизируют свой MAC адрес

```{r}
is_locally_administered <- function(mac) {
  second_nibble <- substr(mac, 2, 2)
  toupper(second_nibble) %in% c("2", "6", "A", "E")
}

non_randomized_devices <- user_with_vendor %>%
  mutate(
    is_global = !is_locally_administered(Station_MAC)
  ) %>%
  filter(is_global) %>%
  select(Station_MAC, OUI, Short_name, Full_name, Probed_ESSIDs) %>%
  distinct()

non_randomized_devices

```

####  Кластеризовать запросы от устройств к точкам доступа по их именам. Определить время появления устройства в зоне радиовидимости и время выхода его из нее

```{r}

device_clusters <- user_clean %>%
  filter(!is.na(Probed_ESSIDs), Probed_ESSIDs != "", Probed_ESSIDs != "N/A") %>%
  mutate(
    Probed_ESSIDs = str_squish(Probed_ESSIDs),
    ESSID_list = str_split(Probed_ESSIDs, ",")
  ) %>%
  unnest(ESSID_list) %>%
  mutate(ESSID_list = str_squish(ESSID_list)) %>%
  filter(ESSID_list != "") %>%
  rename(ESSID = ESSID_list) %>%
  group_by(Station_MAC, ESSID) %>%
  summarise(
    first = min(First_time_seen, na.rm = TRUE),
    last  = max(Last_time_seen,  na.rm = TRUE),
    power = mean(Power),
    .groups = "drop"
  ) 

device_clusters

```

#### Оценим стабильность уровня сигнала внури кластера во времени. Выявим наиболее стабильный кластер.

```{r}
stable_cluster <- device_clusters %>%
  group_by(ESSID) %>%
  summarise(
    .,
    mean_power = mean(power, na.rm = TRUE),
    sd_power = sd(power, na.rm = TRUE),
    stability_score = sd_power/abs(mean_power)
  ) %>% 
  filter(!is.na(stability_score)) %>%
  arrange(., stability_score)
head(stable_cluster, 1) 
```

### Итог

Отчёт написан и оформлен


